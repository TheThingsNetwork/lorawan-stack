// Copyright Â© 2020 The Things Network Foundation, The Things Industries B.V.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//+build ignore

package main

import (
	"bufio"
	"bytes"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

const (
	scriptDir = "lua"
	out       = "scripts.go"
)

func init() {
	log.SetOutput(os.Stderr)
	log.SetFlags(0)
}

type Script struct {
	Name    string
	Comment string
	Body    string
}

var tmpl = template.Must(template.New("scripts").Parse(`
// Code generated by generate_scripts.go. DO NOT EDIT.

package redis

import "github.com/go-redis/redis/v8"

var (
	{{range . -}}
	{{.Comment}}
	{{.Name}} = redis.NewScript(` + "`" + `{{.Body}}` + "`" + `)
	{{end}}
)`))

func isCommentLine(s string) bool {
	return strings.HasPrefix(strings.TrimSpace(s), "--")
}

func main() {
	var scripts []Script
	if err := filepath.Walk(scriptDir, func(p string, info os.FileInfo, err error) error {
		if err != nil {
			log.Fatalf("Failed to walk %q: %s", p, err)
		}
		if info.IsDir() && p != scriptDir {
			return filepath.SkipDir
		}
		if !strings.HasSuffix(p, ".lua") {
			return nil
		}
		f, err := os.Open(p)
		if err != nil {
			log.Fatalf("Failed to open %q: %s", p, err)
		}
		var bodyBuf strings.Builder
		var commentBuf strings.Builder
		sc := bufio.NewScanner(f)
	outer:
		for sc.Scan() {
			s := sc.Text()
			switch {
			case isCommentLine(s):
				if commentBuf.Len() > 0 {
					commentBuf.WriteString("\n")
				}
				commentBuf.WriteString("//" + strings.TrimPrefix(s, "--"))
			case len(s) > 0:
				bodyBuf.WriteString(s)
				break outer
			default:
				commentBuf.Reset()
			}
		}
		for sc.Scan() {
			s := sc.Text()
			switch {
			case len(s) == 0, isCommentLine(s):
			default:
				bodyBuf.WriteString("\n" + s)
			}
		}
		scripts = append(scripts, Script{
			Name:    strings.TrimSuffix(filepath.Base(p), ".lua") + "Script",
			Comment: commentBuf.String(),
			Body:    bodyBuf.String(),
		})
		return nil
	}); err != nil {
		log.Fatalf("Failed to walk %q: %s", scriptDir, err)
	}
	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, scripts); err != nil {
		log.Fatalf("Failed to execute template: %s", err)
	}
	b, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("Failed to format %q: %s", out, err)
	}
	if err := ioutil.WriteFile(out, b, 0o644); err != nil {
		log.Fatalf("Failed to write to %q: %s", out, err)
	}
}
