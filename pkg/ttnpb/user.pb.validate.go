// Code generated by protoc-gen-fieldmask. DO NOT EDIT.

package ttnpb

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"github.com/gogo/protobuf/types"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = types.DynamicAny{}
)

// define the regex for a UUID once up-front
var _user_uuidPattern = regexp.MustCompile("^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$")

// ValidateFields checks the field values on User with the rules defined in the
// proto definition for this message. If any rules are violated, an error is returned.
func (m *User) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UserFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserValidationError{
						field:  "ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "created_at":

			if v, ok := interface{}(&m.CreatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserValidationError{
						field:  "created_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "updated_at":

			if v, ok := interface{}(&m.UpdatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserValidationError{
						field:  "updated_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "name":

			if utf8.RuneCountInString(m.GetName()) > 50 {
				return UserValidationError{
					field:  "name",
					reason: "value length must be at most 50 runes",
				}
			}

		case "description":

			if utf8.RuneCountInString(m.GetDescription()) > 2000 {
				return UserValidationError{
					field:  "description",
					reason: "value length must be at most 2000 runes",
				}
			}

		case "attributes":

			for key, val := range m.GetAttributes() {
				_ = val

				if utf8.RuneCountInString(key) > 36 {
					return UserValidationError{
						field:  fmt.Sprintf("attributes[%v]", key),
						reason: "value length must be at most 36 runes",
					}
				}

				if !_User_Attributes_Pattern.MatchString(key) {
					return UserValidationError{
						field:  fmt.Sprintf("attributes[%v]", key),
						reason: "value does not match regex pattern \"^[a-z0-9](?:[-]?[a-z0-9]){2,}$\"",
					}
				}

				// no validation rules for Attributes[key]
			}

		case "contact_info":

			for idx, item := range m.GetContactInfo() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return UserValidationError{
							field:  fmt.Sprintf("contact_info[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		case "primary_email_address":

			if err := m._validateEmail(m.GetPrimaryEmailAddress()); err != nil {
				return UserValidationError{
					field:  "primary_email_address",
					reason: "value must be a valid email address",
					cause:  err,
				}
			}

		case "primary_email_address_validated_at":

			if v, ok := interface{}(m.GetPrimaryEmailAddressValidatedAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserValidationError{
						field:  "primary_email_address_validated_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "password":
			// no validation rules for Password
		case "password_updated_at":

			if v, ok := interface{}(m.GetPasswordUpdatedAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserValidationError{
						field:  "password_updated_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "require_password_update":
			// no validation rules for RequirePasswordUpdate
		case "state":

			if _, ok := State_name[int32(m.GetState())]; !ok {
				return UserValidationError{
					field:  "state",
					reason: "value must be one of the defined enum values",
				}
			}

		case "admin":
			// no validation rules for Admin
		case "temporary_password":
			// no validation rules for TemporaryPassword
		case "temporary_password_created_at":

			if v, ok := interface{}(m.GetTemporaryPasswordCreatedAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserValidationError{
						field:  "temporary_password_created_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "temporary_password_expires_at":

			if v, ok := interface{}(m.GetTemporaryPasswordExpiresAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserValidationError{
						field:  "temporary_password_expires_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "profile_picture":

			if v, ok := interface{}(m.GetProfilePicture()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserValidationError{
						field:  "profile_picture",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return UserValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

func (m *User) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *User) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// UserValidationError is the validation error returned by User.ValidateFields
// if the designated constraints aren't met.
type UserValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserValidationError) ErrorName() string { return "UserValidationError" }

// Error satisfies the builtin error interface
func (e UserValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUser.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserValidationError{}

var _User_Attributes_Pattern = regexp.MustCompile("^[a-z0-9](?:[-]?[a-z0-9]){2,}$")

// ValidateFields checks the field values on Picture with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *Picture) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = PictureFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "embedded":

			if v, ok := interface{}(m.GetEmbedded()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return PictureValidationError{
						field:  "embedded",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "sizes":

			for key, val := range m.GetSizes() {
				_ = val

				// no validation rules for Sizes[key]

				if _, err := url.Parse(val); err != nil {
					return PictureValidationError{
						field:  fmt.Sprintf("sizes[%v]", key),
						reason: "value must be a valid URI",
						cause:  err,
					}
				}

			}

		default:
			return PictureValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// PictureValidationError is the validation error returned by
// Picture.ValidateFields if the designated constraints aren't met.
type PictureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PictureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PictureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PictureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PictureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PictureValidationError) ErrorName() string { return "PictureValidationError" }

// Error satisfies the builtin error interface
func (e PictureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPicture.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PictureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PictureValidationError{}

// ValidateFields checks the field values on Users with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned.
func (m *Users) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UsersFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "users":

			for idx, item := range m.GetUsers() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return UsersValidationError{
							field:  fmt.Sprintf("users[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return UsersValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UsersValidationError is the validation error returned by
// Users.ValidateFields if the designated constraints aren't met.
type UsersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UsersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UsersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UsersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UsersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UsersValidationError) ErrorName() string { return "UsersValidationError" }

// Error satisfies the builtin error interface
func (e UsersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUsers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UsersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UsersValidationError{}

// ValidateFields checks the field values on GetUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetUserRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetUserRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetUserRequestValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetUserRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return GetUserRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetUserRequestValidationError is the validation error returned by
// GetUserRequest.ValidateFields if the designated constraints aren't met.
type GetUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserRequestValidationError) ErrorName() string { return "GetUserRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserRequestValidationError{}

// ValidateFields checks the field values on CreateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *CreateUserRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = CreateUserRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user":

			if v, ok := interface{}(&m.User).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return CreateUserRequestValidationError{
						field:  "user",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "invitation_token":
			// no validation rules for InvitationToken
		default:
			return CreateUserRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// CreateUserRequestValidationError is the validation error returned by
// CreateUserRequest.ValidateFields if the designated constraints aren't met.
type CreateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserRequestValidationError) ErrorName() string {
	return "CreateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserRequestValidationError{}

// ValidateFields checks the field values on UpdateUserRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UpdateUserRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UpdateUserRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user":

			if v, ok := interface{}(&m.User).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateUserRequestValidationError{
						field:  "user",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "field_mask":

			if v, ok := interface{}(&m.FieldMask).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateUserRequestValidationError{
						field:  "field_mask",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return UpdateUserRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UpdateUserRequestValidationError is the validation error returned by
// UpdateUserRequest.ValidateFields if the designated constraints aren't met.
type UpdateUserRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserRequestValidationError) ErrorName() string {
	return "UpdateUserRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserRequestValidationError{}

// ValidateFields checks the field values on CreateTemporaryPasswordRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned.
func (m *CreateTemporaryPasswordRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = CreateTemporaryPasswordRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return CreateTemporaryPasswordRequestValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return CreateTemporaryPasswordRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// CreateTemporaryPasswordRequestValidationError is the validation error
// returned by CreateTemporaryPasswordRequest.ValidateFields if the designated
// constraints aren't met.
type CreateTemporaryPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTemporaryPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTemporaryPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTemporaryPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTemporaryPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTemporaryPasswordRequestValidationError) ErrorName() string {
	return "CreateTemporaryPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTemporaryPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTemporaryPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTemporaryPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTemporaryPasswordRequestValidationError{}

// ValidateFields checks the field values on UpdateUserPasswordRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UpdateUserPasswordRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UpdateUserPasswordRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateUserPasswordRequestValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "new":
			// no validation rules for New
		case "old":
			// no validation rules for Old
		case "revoke_all_access":
			// no validation rules for RevokeAllAccess
		default:
			return UpdateUserPasswordRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UpdateUserPasswordRequestValidationError is the validation error returned by
// UpdateUserPasswordRequest.ValidateFields if the designated constraints
// aren't met.
type UpdateUserPasswordRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserPasswordRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserPasswordRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserPasswordRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserPasswordRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserPasswordRequestValidationError) ErrorName() string {
	return "UpdateUserPasswordRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserPasswordRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserPasswordRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserPasswordRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserPasswordRequestValidationError{}

// ValidateFields checks the field values on ListUserAPIKeysRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ListUserAPIKeysRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = ListUserAPIKeysRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return ListUserAPIKeysRequestValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "limit":

			if m.GetLimit() > 1000 {
				return ListUserAPIKeysRequestValidationError{
					field:  "limit",
					reason: "value must be less than or equal to 1000",
				}
			}

		case "page":
			// no validation rules for Page
		default:
			return ListUserAPIKeysRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// ListUserAPIKeysRequestValidationError is the validation error returned by
// ListUserAPIKeysRequest.ValidateFields if the designated constraints aren't met.
type ListUserAPIKeysRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserAPIKeysRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserAPIKeysRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserAPIKeysRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserAPIKeysRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserAPIKeysRequestValidationError) ErrorName() string {
	return "ListUserAPIKeysRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserAPIKeysRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserAPIKeysRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserAPIKeysRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserAPIKeysRequestValidationError{}

// ValidateFields checks the field values on GetUserAPIKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *GetUserAPIKeyRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = GetUserAPIKeyRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return GetUserAPIKeyRequestValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "key_id":
			// no validation rules for KeyID
		default:
			return GetUserAPIKeyRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// GetUserAPIKeyRequestValidationError is the validation error returned by
// GetUserAPIKeyRequest.ValidateFields if the designated constraints aren't met.
type GetUserAPIKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetUserAPIKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetUserAPIKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetUserAPIKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetUserAPIKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetUserAPIKeyRequestValidationError) ErrorName() string {
	return "GetUserAPIKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetUserAPIKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetUserAPIKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetUserAPIKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetUserAPIKeyRequestValidationError{}

// ValidateFields checks the field values on CreateUserAPIKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *CreateUserAPIKeyRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = CreateUserAPIKeyRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return CreateUserAPIKeyRequestValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "name":

			if utf8.RuneCountInString(m.GetName()) > 50 {
				return CreateUserAPIKeyRequestValidationError{
					field:  "name",
					reason: "value length must be at most 50 runes",
				}
			}

		case "rights":

			for idx, item := range m.GetRights() {
				_, _ = idx, item

				if _, ok := Right_name[int32(item)]; !ok {
					return CreateUserAPIKeyRequestValidationError{
						field:  fmt.Sprintf("rights[%v]", idx),
						reason: "value must be one of the defined enum values",
					}
				}

			}

		default:
			return CreateUserAPIKeyRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// CreateUserAPIKeyRequestValidationError is the validation error returned by
// CreateUserAPIKeyRequest.ValidateFields if the designated constraints aren't met.
type CreateUserAPIKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateUserAPIKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateUserAPIKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateUserAPIKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateUserAPIKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateUserAPIKeyRequestValidationError) ErrorName() string {
	return "CreateUserAPIKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateUserAPIKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateUserAPIKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateUserAPIKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateUserAPIKeyRequestValidationError{}

// ValidateFields checks the field values on UpdateUserAPIKeyRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UpdateUserAPIKeyRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UpdateUserAPIKeyRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateUserAPIKeyRequestValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "api_key":

			if v, ok := interface{}(&m.APIKey).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UpdateUserAPIKeyRequestValidationError{
						field:  "api_key",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return UpdateUserAPIKeyRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UpdateUserAPIKeyRequestValidationError is the validation error returned by
// UpdateUserAPIKeyRequest.ValidateFields if the designated constraints aren't met.
type UpdateUserAPIKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUserAPIKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUserAPIKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUserAPIKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUserAPIKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUserAPIKeyRequestValidationError) ErrorName() string {
	return "UpdateUserAPIKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUserAPIKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUserAPIKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUserAPIKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUserAPIKeyRequestValidationError{}

// ValidateFields checks the field values on Invitation with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *Invitation) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = InvitationFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "email":

			if err := m._validateEmail(m.GetEmail()); err != nil {
				return InvitationValidationError{
					field:  "email",
					reason: "value must be a valid email address",
					cause:  err,
				}
			}

		case "token":
			// no validation rules for Token
		case "expires_at":

			if v, ok := interface{}(&m.ExpiresAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return InvitationValidationError{
						field:  "expires_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "created_at":

			if v, ok := interface{}(&m.CreatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return InvitationValidationError{
						field:  "created_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "updated_at":

			if v, ok := interface{}(&m.UpdatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return InvitationValidationError{
						field:  "updated_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "accepted_at":

			if v, ok := interface{}(m.GetAcceptedAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return InvitationValidationError{
						field:  "accepted_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "accepted_by":

			if v, ok := interface{}(m.GetAcceptedBy()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return InvitationValidationError{
						field:  "accepted_by",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return InvitationValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

func (m *Invitation) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *Invitation) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// InvitationValidationError is the validation error returned by
// Invitation.ValidateFields if the designated constraints aren't met.
type InvitationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvitationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvitationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvitationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvitationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvitationValidationError) ErrorName() string { return "InvitationValidationError" }

// Error satisfies the builtin error interface
func (e InvitationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvitation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvitationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvitationValidationError{}

// ValidateFields checks the field values on ListInvitationsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ListInvitationsRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = ListInvitationsRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "limit":

			if m.GetLimit() > 1000 {
				return ListInvitationsRequestValidationError{
					field:  "limit",
					reason: "value must be less than or equal to 1000",
				}
			}

		case "page":
			// no validation rules for Page
		default:
			return ListInvitationsRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// ListInvitationsRequestValidationError is the validation error returned by
// ListInvitationsRequest.ValidateFields if the designated constraints aren't met.
type ListInvitationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInvitationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInvitationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInvitationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInvitationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInvitationsRequestValidationError) ErrorName() string {
	return "ListInvitationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListInvitationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInvitationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInvitationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInvitationsRequestValidationError{}

// ValidateFields checks the field values on Invitations with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *Invitations) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = InvitationsFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "invitations":

			for idx, item := range m.GetInvitations() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return InvitationsValidationError{
							field:  fmt.Sprintf("invitations[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return InvitationsValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// InvitationsValidationError is the validation error returned by
// Invitations.ValidateFields if the designated constraints aren't met.
type InvitationsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InvitationsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InvitationsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InvitationsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InvitationsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InvitationsValidationError) ErrorName() string { return "InvitationsValidationError" }

// Error satisfies the builtin error interface
func (e InvitationsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInvitations.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InvitationsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InvitationsValidationError{}

// ValidateFields checks the field values on SendInvitationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *SendInvitationRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = SendInvitationRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "email":

			if err := m._validateEmail(m.GetEmail()); err != nil {
				return SendInvitationRequestValidationError{
					field:  "email",
					reason: "value must be a valid email address",
					cause:  err,
				}
			}

		default:
			return SendInvitationRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

func (m *SendInvitationRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *SendInvitationRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// SendInvitationRequestValidationError is the validation error returned by
// SendInvitationRequest.ValidateFields if the designated constraints aren't met.
type SendInvitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendInvitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendInvitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendInvitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendInvitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendInvitationRequestValidationError) ErrorName() string {
	return "SendInvitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendInvitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendInvitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendInvitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendInvitationRequestValidationError{}

// ValidateFields checks the field values on DeleteInvitationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *DeleteInvitationRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = DeleteInvitationRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "email":

			if err := m._validateEmail(m.GetEmail()); err != nil {
				return DeleteInvitationRequestValidationError{
					field:  "email",
					reason: "value must be a valid email address",
					cause:  err,
				}
			}

		default:
			return DeleteInvitationRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

func (m *DeleteInvitationRequest) _validateHostname(host string) error {
	s := strings.ToLower(strings.TrimSuffix(host, "."))

	if len(host) > 253 {
		return errors.New("hostname cannot exceed 253 characters")
	}

	for _, part := range strings.Split(s, ".") {
		if l := len(part); l == 0 || l > 63 {
			return errors.New("hostname part must be non-empty and cannot exceed 63 characters")
		}

		if part[0] == '-' {
			return errors.New("hostname parts cannot begin with hyphens")
		}

		if part[len(part)-1] == '-' {
			return errors.New("hostname parts cannot end with hyphens")
		}

		for _, r := range part {
			if (r < 'a' || r > 'z') && (r < '0' || r > '9') && r != '-' {
				return fmt.Errorf("hostname parts can only contain alphanumeric characters or hyphens, got %q", string(r))
			}
		}
	}

	return nil
}

func (m *DeleteInvitationRequest) _validateEmail(addr string) error {
	a, err := mail.ParseAddress(addr)
	if err != nil {
		return err
	}
	addr = a.Address

	if len(addr) > 254 {
		return errors.New("email addresses cannot exceed 254 characters")
	}

	parts := strings.SplitN(addr, "@", 2)

	if len(parts[0]) > 64 {
		return errors.New("email address local phrase cannot exceed 64 characters")
	}

	return m._validateHostname(parts[1])
}

// DeleteInvitationRequestValidationError is the validation error returned by
// DeleteInvitationRequest.ValidateFields if the designated constraints aren't met.
type DeleteInvitationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteInvitationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteInvitationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteInvitationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteInvitationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteInvitationRequestValidationError) ErrorName() string {
	return "DeleteInvitationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteInvitationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteInvitationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteInvitationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteInvitationRequestValidationError{}

// ValidateFields checks the field values on UserSessionIdentifiers with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UserSessionIdentifiers) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UserSessionIdentifiersFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserSessionIdentifiersValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "session_id":

			if utf8.RuneCountInString(m.GetSessionID()) > 64 {
				return UserSessionIdentifiersValidationError{
					field:  "session_id",
					reason: "value length must be at most 64 runes",
				}
			}

		default:
			return UserSessionIdentifiersValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UserSessionIdentifiersValidationError is the validation error returned by
// UserSessionIdentifiers.ValidateFields if the designated constraints aren't met.
type UserSessionIdentifiersValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSessionIdentifiersValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSessionIdentifiersValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSessionIdentifiersValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSessionIdentifiersValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSessionIdentifiersValidationError) ErrorName() string {
	return "UserSessionIdentifiersValidationError"
}

// Error satisfies the builtin error interface
func (e UserSessionIdentifiersValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSessionIdentifiers.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSessionIdentifiersValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSessionIdentifiersValidationError{}

// ValidateFields checks the field values on UserSession with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned.
func (m *UserSession) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UserSessionFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserSessionValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "session_id":

			if utf8.RuneCountInString(m.GetSessionID()) > 64 {
				return UserSessionValidationError{
					field:  "session_id",
					reason: "value length must be at most 64 runes",
				}
			}

		case "created_at":

			if v, ok := interface{}(&m.CreatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserSessionValidationError{
						field:  "created_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "updated_at":

			if v, ok := interface{}(&m.UpdatedAt).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserSessionValidationError{
						field:  "updated_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "expires_at":

			if v, ok := interface{}(m.GetExpiresAt()).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return UserSessionValidationError{
						field:  "expires_at",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		default:
			return UserSessionValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UserSessionValidationError is the validation error returned by
// UserSession.ValidateFields if the designated constraints aren't met.
type UserSessionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSessionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSessionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSessionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSessionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSessionValidationError) ErrorName() string { return "UserSessionValidationError" }

// Error satisfies the builtin error interface
func (e UserSessionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSession.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSessionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSessionValidationError{}

// ValidateFields checks the field values on UserSessions with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *UserSessions) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = UserSessionsFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "sessions":

			for idx, item := range m.GetSessions() {
				_, _ = idx, item

				if v, ok := interface{}(item).(interface{ ValidateFields(...string) error }); ok {
					if err := v.ValidateFields(subs...); err != nil {
						return UserSessionsValidationError{
							field:  fmt.Sprintf("sessions[%v]", idx),
							reason: "embedded message failed validation",
							cause:  err,
						}
					}
				}

			}

		default:
			return UserSessionsValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// UserSessionsValidationError is the validation error returned by
// UserSessions.ValidateFields if the designated constraints aren't met.
type UserSessionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UserSessionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UserSessionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UserSessionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UserSessionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UserSessionsValidationError) ErrorName() string { return "UserSessionsValidationError" }

// Error satisfies the builtin error interface
func (e UserSessionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUserSessions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UserSessionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UserSessionsValidationError{}

// ValidateFields checks the field values on ListUserSessionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *ListUserSessionsRequest) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = ListUserSessionsRequestFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "user_ids":

			if v, ok := interface{}(&m.UserIdentifiers).(interface{ ValidateFields(...string) error }); ok {
				if err := v.ValidateFields(subs...); err != nil {
					return ListUserSessionsRequestValidationError{
						field:  "user_ids",
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		case "order":
			// no validation rules for Order
		case "limit":

			if m.GetLimit() > 1000 {
				return ListUserSessionsRequestValidationError{
					field:  "limit",
					reason: "value must be less than or equal to 1000",
				}
			}

		case "page":
			// no validation rules for Page
		default:
			return ListUserSessionsRequestValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// ListUserSessionsRequestValidationError is the validation error returned by
// ListUserSessionsRequest.ValidateFields if the designated constraints aren't met.
type ListUserSessionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUserSessionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUserSessionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUserSessionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUserSessionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUserSessionsRequestValidationError) ErrorName() string {
	return "ListUserSessionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUserSessionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUserSessionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUserSessionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUserSessionsRequestValidationError{}

// ValidateFields checks the field values on Picture_Embedded with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned.
func (m *Picture_Embedded) ValidateFields(paths ...string) error {
	if m == nil {
		return nil
	}

	if len(paths) == 0 {
		paths = Picture_EmbeddedFieldPathsNested
	}

	for name, subs := range _processPaths(append(paths[:0:0], paths...)) {
		_ = subs
		switch name {
		case "mime_type":
			// no validation rules for MimeType
		case "data":
			// no validation rules for Data
		default:
			return Picture_EmbeddedValidationError{
				field:  name,
				reason: "invalid field path",
			}
		}
	}
	return nil
}

// Picture_EmbeddedValidationError is the validation error returned by
// Picture_Embedded.ValidateFields if the designated constraints aren't met.
type Picture_EmbeddedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Picture_EmbeddedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Picture_EmbeddedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Picture_EmbeddedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Picture_EmbeddedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Picture_EmbeddedValidationError) ErrorName() string { return "Picture_EmbeddedValidationError" }

// Error satisfies the builtin error interface
func (e Picture_EmbeddedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPicture_Embedded.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Picture_EmbeddedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Picture_EmbeddedValidationError{}
